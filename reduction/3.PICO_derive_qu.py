
#==============================================
# BEFORE RUNNING
#==============================================

'''
This is the code for deriving the $q$ and $u$ values of the asteroids taken by PICO (Ikeda et al. 2004).


1. 
 - Input file:  
   Phot_{DATE}_{Object_name}.csv        Photometric result of each images generated by 2.PICO_aper_photometry.py.
 
 - Outout file:
   Pol_{DATE}_{Object_name}.csv         Polarimetric result of each set
     
'''     


#==============================================
# INPUT VALUE
#==============================================
subpath  = 'Directory path where Phot_{DATE}_{Object_name}.csv is saved.' 
Observatory = {'lon': 139.56,
               'lat': 35.67,
               'elevation': 0.01} #NAOJ
Target_name = '3200'

input_name = 'Pol_{DATE}_{Object_name}.csv' #Photometric result of each images generated by 2.PICO_aper_photometry.py.



#==============================================
# IMPORT PACKAGES AND DEFINE THE FUNCTION
#==============================================
import glob 
import os
import astropy
import pandas as pd
import numpy as np

from astroquery.jplhorizons import Horizons
from astropy.time import Time



def PICO_qu(kappa,err_kappa,condition='normal'):

    k_0 = kappa[0]
    k_45 = kappa[1]
    k_22 = kappa[2]
    k_67 = kappa[3]

    ek_0 = err_kappa[0]
    ek_45 = err_kappa[1]
    ek_22 = err_kappa[2]
    ek_67 = err_kappa[3]

    aQ = np.sqrt(k_0/k_45)
    aU = np.sqrt(k_22/k_67)

    q = (1-aQ)/(1+aQ) #Q/I
    u = (1-aU)/(1+aU) #U/I

    q_ran = aQ/((aQ + 1)**2)  *  np.sqrt(ek_0 + ek_45)
    u_ran = aU/((aU + 1)**2)  *  np.sqrt(ek_22 + ek_67)    


    ###==================== 
    ## Correct Efficiency
    ###==================== 
    eff =  0.9952
    efferr = 0.0002 

    qq = q/eff
    uu = u/eff

    #random error of corrected q,u
    qq_ran = q_ran/eff
    uu_ran = u_ran/eff

    #the systematic errors
    qq_sys = np.abs(q)*efferr/eff**2
    uu_sys = np.abs(u)*efferr/eff**2
    
    print('effi',np.sqrt(qq**2+uu**2),eff, efferr,efferr/eff**2*np.sqrt(qq**2+uu**2),
          np.sqrt((qq*qq_sys)**2+(uu*uu_sys)**2)/np.sqrt(qq**2+uu**2) *100, efferr/eff**2*np.sqrt(qq**2+uu**2) *100)

    ###==================== 
    ## Correc Instrumental polarization
    ###====================  
    q_inst = 0.000426
    u_inst = 0.001166
    eq_inst =  0.001
    eu_inst =  0.001
        
    qqq = qq - q_inst
    uuu = uu - u_inst

    #random error of corrected q,u
    qqq_ran = qq_ran
    uuu_ran = uu_ran    

    #the systematic errors    
    qqq_sys = np.sqrt( qq_sys**2 + eq_inst**2)
    uuu_sys = np.sqrt( uu_sys**2 + eu_inst**2)

    ###==================== 
    ## Transform_CelestialCoord
    ###====================    
    the = 93.87
    the_err = 0.18

    theta = the
    theta = np.deg2rad(theta)
    the_err = np.deg2rad(the_err)


    qqqq = qqq * np.cos(2*theta) + uuu*np.sin(2*theta)
    uuuu = -qqq * np.sin(2*theta) + uuu*np.cos(2*theta)

    qqqq_ran = np.sqrt( (qqq_ran*np.cos(2*theta))**2 + (uuu_ran*np.sin(2*theta))**2 )
    uuuu_ran = np.sqrt( (qqq_ran*np.sin(2*theta))**2 + (uuu_ran*np.cos(2*theta))**2 )

    qqqq_sys = np.sqrt( (qqq_sys*np.cos(2*theta))**2 +                         (uuu_sys*np.sin(2*theta))**2 +                         (np.pi/180*2*uuuu*the_err)**2 )
    uuuu_sys = np.sqrt( (qqq_sys*np.sin(2*theta))**2 +                         (uuu_sys*np.cos(2*theta))**2 +                         (np.pi/180*2*qqqq*the_err)**2 ) 
    return(qqqq, qqqq_ran, qqqq_sys, uuuu, uuuu_ran, uuuu_sys)


def weight(x,err):
    x = np.array(x)
    err = np.array(err)
    
    w = 1/err**2
    sumW = np.sum(w)
    weight = w/sumW
    
    xav = np.sum(weight*x)
    Err = 1/np.sqrt(sumW)
    
    return(xav,Err)

def extract_exp(LIST):
    hey = []
    for i in LIST:
        hey.append(list(i)[0])
    return(set(hey))    


#==============================================
# DERIVING q AND u
#==============================================
filename = os.path.join(subpath,input_name)                          
Phot = pd.read_csv(filename)


#======================================#
#             Polarimetry              #
#======================================#    

Pol_log = pd.DataFrame({})
order = np.arange(0,len(Phot),8)    



for i in order:
    Flux_0_e = Phot['Flux [e]'].values[i]
    Flux_0_o = Phot['Flux [e]'].values[i+1]
    eFlux_0_e = Phot['eFlux [e]'].values[i]
    eFlux_0_o = Phot['eFlux [e]'].values[i+1]
    err_0 = (Flux_0_e/Flux_0_o**2 * eFlux_0_o)**2 + (1/Flux_0_o * eFlux_0_e)**2
    
    Flux_45_e = Phot['Flux [e]'].values[i+2]
    eFlux_45_e = Phot['eFlux [e]'].values[i+2]
    Flux_45_o = Phot['Flux [e]'].values[i+3]
    eFlux_45_o = Phot['eFlux [e]'].values[i+3]
    err_45 = (Flux_45_e/Flux_45_o**2 * eFlux_45_o)**2 + (1/Flux_45_o * eFlux_45_e)**2

    Flux_22_e = Phot['Flux [e]'].values[i+4]
    eFlux_22_e = Phot['eFlux [e]'].values[i+4]
    Flux_22_o = Phot['Flux [e]'].values[i+5]
    eFlux_22_o = Phot['eFlux [e]'].values[i+5]
    err_22 = (Flux_22_e/Flux_22_o**2 * eFlux_22_o)**2 + (1/Flux_22_o * eFlux_22_e)**2    

    Flux_67_e = Phot['Flux [e]'].values[i+6]
    eFlux_67_e = Phot['eFlux [e]'].values[i+6]
    Flux_67_o = Phot['Flux [e]'].values[i+7]
    eFlux_67_o = Phot['eFlux [e]'].values[i+7]
    err_67 = (Flux_67_e/Flux_67_o**2 * eFlux_67_o)**2 + (1/Flux_67_o * eFlux_67_e)**2


    kappa = [Flux_0_e/Flux_0_o, Flux_22_e/Flux_22_o, Flux_45_e/Flux_45_o, Flux_67_e/Flux_67_o]
    ekappa = [err_0, err_22,  err_45, err_67]

    q, ran_q, sys_q, u, ran_u, sys_u = PICO_qu(kappa, ekappa)
    eq = np.sqrt(ran_q**2 + sys_q**2)
    eu = np.sqrt(ran_u**2 + sys_u**2)
    
    P = np.sqrt(q**2 + u**2)
    P_ran = np.sqrt( (q*ran_q)**2 + (u*ran_u)**2 )/P
    P_sys = np.sqrt( (q*sys_q)**2 + (u*sys_u)**2 )/P
    P_error = np.sqrt(P_ran**2 + P_sys**2) #Polarization error  
    Theta = np.rad2deg(1/2* np.arctan2(u,q))    
    if P**2 > P_ran**2:
        print('Random error bias correction is done.')
        P_cor = np.sqrt(P**2 - P_ran**2)
        ran_PolAng = 1/2 * 180/3.14 * P_ran/P_cor
        sys_PolAng = 1/2 * 180/3.14 * P_sys/P_cor
        eTheta = np.sqrt(ran_PolAng**2 + sys_PolAng**2)

    elif P**2 < P_ran**2 :
        print('Due to P < randome error, random error bias correction is NOT done.')
        P_cor = 0    
        ran_PolAng = 51.96
        sys_PolAng = 51.96
        eTheta = 51.96

    if Theta < 0:
        Theta = Theta + 180
    elif Theta > 180:
        Theta = Theta - 180
    
    
    
    JD = np.mean(Phot['JD'].values[i:i+7])
    UT = Time(JD,format='jd').isot[:-4]
    DATE = UT.split('T')[0] 
    UT = UT.split('T')[1]
    Exp = set(Phot['EXP [s]'].values[i:i+7])
    Airmass =  np.mean(Phot['Airmass'].values[i:i+7])
    Object = Target_name
    Date = Phot['DATE'].values[i]
    SNR = np.mean(Phot['SNR'].values[i:i+7])
    
    obj = Horizons(id=Target_name,location=Observatory, epochs=JD)
    eph = obj.ephemerides()
    psANG = eph['sunTargetPA'][0] #[deg]
    pA = eph['alpha'][0] #[deg]   
    
    
    if psANG + 90 < 180:
        pi = psANG + 90
    else:
        pi = psANG - 90

    theta_r = Theta - pi
    Pr = P_cor * np.cos(2*np.deg2rad(theta_r))
    
    filename = Phot['filename'].values[i].split('.')[0]+'~'+Phot['filename'].values[i+7].split('-')[-1]
    Pol_log = Pol_log.append({'Filename':filename,
                              'JD':JD,
                              'UT':UT,
                              'alpha':pA,
                              'SunTargetPA':psANG,
                              'EXP [s]':Exp,
                              'Airmass':Airmass,
                              'Object':eph['targetname'][0],
                              'Filter':'Rc',
                              'DATE':Date,
                              'SNR':SNR,
                              'Pr [%]':Pr*100,
                              'Theta_r':theta_r,
                              'P [%]':P_cor*100,
                              'sys_P [%]':P_sys*100,
                              'ran_P [%]':P_ran*100,
                              'eP [%]':P_error*100,
                              'q':q,
                              'u':u,
                              'ran_q':ran_q,
                              'sys_q':sys_q,
                              'ran_u':ran_u,
                              'sys_u':sys_u,
                              'eq':eq,
                              'eu':eu,
                              'Theta':Theta,
                              'eTheta':eTheta,
                              'sys_Theta':sys_PolAng,
                              'ran_Theta':ran_PolAng},
                             ignore_index=True)     
    
q_av, ranq_av = weight(Pol_log['q'],Pol_log['ran_q'])
u_av, ranu_av = weight(Pol_log['u'],Pol_log['ran_u'])
sysq_av = np.mean(Pol_log['sys_q'])
sysu_av = np.mean(Pol_log['sys_u'])
errq_av = (ranq_av**2 + sysq_av**2)**0.5
erru_av = (ranu_av**2 + sysu_av**2)**0.5

P = np.sqrt(q_av**2+u_av**2)
ran_P = np.sqrt((q_av*ranq_av)**2 + (u_av*ranu_av)**2)/P
sys_P = np.sqrt((q_av*sysq_av)**2 + (u_av*sysu_av)**2)/P
eP = np.sqrt(ran_P**2 + sys_P**2)

Theta = 1/2*np.rad2deg(np.arctan2(u_av,q_av))
if P**2 - ran_P**2 < 0:
    Pcor = 0
    ran_PolAng = 51.96
    sys_PolAng = 1/2 * 180/3.14 * P_sys/Pcor
    PolAng_error = 51.96
    # Naghizadeh-Khouei & Clarke 1993
else:
    Pcor = np.sqrt(P**2 - ran_P**2)
    ran_PolAng = 1/2 * 180/3.14 * P_ran/Pcor
    sys_PolAng = 1/2 * 180/3.14 * P_sys/Pcor
    PolAng_error = np.sqrt(ran_PolAng**2 + sys_PolAng**2)      


if Theta < 0:
    Theta = Theta + 180
elif Theta > 180:
    Theta = Theta - 180    



JD = np.mean(Pol_log['JD'])
Exp = extract_exp(Pol_log['EXP [s]'].values)
Airmass = '{0:.1f}--{1:.1f}'.format(min(Pol_log['Airmass'].values),max(Pol_log['Airmass'].values))
Object = Pol_log['Object'].values[0]
Date = Pol_log['DATE'].values[0]
SNR = '{0:.1f}--{1:.1f}'.format(min(Pol_log['SNR'].values),max(Pol_log['SNR'].values))


UT = Pol_log['UT'].values[0] +'-'+Pol_log['UT'].values[-1].split(' ')[-1]


#Translate to the scattering plane==============================
obj = Horizons(id=Target_name,location=Observatory, epochs=JD)
eph = obj.ephemerides()
psANG = eph['sunTargetPA'][0] #[deg]
pA = eph['alpha'][0] #[deg]    

if psANG + 90 < 180:
    pi = psANG + 90
else:
    pi = psANG - 90

theta_r = Theta - pi
Pr = Pcor * np.cos(2*np.deg2rad(theta_r))    


Pol_log = Pol_log.append({'Filename':'Weighted mean',
                              'JD':JD,
                              'UT':UT,
                              'alpha':pA,
                              'SunTargetPA':psANG,
                              'EXP [s]':Exp,
                              'Airmass':Airmass,
                              'Object':eph['targetname'][0],
                              'Filter':'Rc',
                              'DATE':Date,
                              'SNR':SNR,
                              'Pr [%]':Pr*100,
                              'Theta_r':theta_r,
                              'P [%]':P_cor*100,
                              'sys_P [%]':P_sys*100,
                              'ran_P [%]':P_ran*100,
                              'eP [%]':P_error*100,
                              'q':q,
                              'u':u,
                              'ran_q':ran_q,
                              'sys_q':sys_q,
                              'ran_u':ran_u,
                              'sys_u':sys_u,
                              'eq':eq,
                              'eu':eu,
                              'Theta':Theta,
                              'eTheta':eTheta,
                              'sys_Theta':sys_PolAng,
                              'ran_Theta':ran_PolAng},
                             ignore_index=True) 

new_index = ['Filename','DATE','UT','JD','Object','Filter',
             'alpha','Pr [%]','eP [%]','Theta_r','eTheta',
             'q','ran_q','sys_q','eq',
             'u','ran_u','sys_u','eu',
             'P [%]','sys_P [%]','ran_P [%]',
             'Theta','sys_Theta','ran_Theta',
             'EXP [s]','Airmass','SunTargetPA','SNR']
Pol_log = Pol_log.reindex(columns = new_index)  
Pol_log = Pol_log.round({'alpha':2,'Pr [%]':2,'eP [%]':2,'Theta_r':1,'eTheta':1,
                         'q':4,'ran_q':4,'sys_q':4,'eq':4,
                         'u':4,'ran_u':4,'sys_u':4,'eu':4,
                         'P [%]':2,'sys_P [%]':2,'ran_P [%]':2,
                         'Theta':1,'sys_Theta':1,'ran_Theta':1,
                         'EXP [s]':1,'SunTargetPA':1,'SNR':1})


Object_name = Object.split(' ')[0]
DATE = Date.replace('-','_')
FILENAME = 'Pol_'+DATE+'_'+Target_name+'.csv'
FILENAME = os.path.join(subpath,FILENAME)
Pol_log.to_csv(FILENAME)        

